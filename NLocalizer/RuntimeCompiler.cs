/*******************************************************************************

  NLocalizer (C) 2010 Krzysztof Arkadiusz Prusik
  The fast, simple solution for localizing .NET applications, by text files.
  Latest version: http://NLocalizer.codeplex.com/

  $Id: RuntimeCompiler.cs 3210 2010-10-03 03:06:53Z unknown $

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

*******************************************************************************/
using System;
using System.Collections.Generic;
using System.Text;
using System.CodeDom.Compiler;
using Microsoft.CSharp;
using System.Reflection;
using System.IO;
using System.Windows.Forms;

namespace NLocalizer
{
    /// <summary>
    /// Helper to compile translation class in runtime mode.
    /// </summary>
    public static class RuntimeCompiler
    {
        private const string Namespace = "NLocalizer";
        private const string ClassName = "RuntimeTranslator";

        private const string MethodTranslate = "Translate";
        private const string MethodRestore = "Restore";
        private const string MethodCreate = "Create";
        private const string MethodShowDialog = "ShowDialog";

        /// <summary>
        /// Creates StringBuilder from translation.
        /// </summary>
        /// <param name="translation">The translation.</param>
        /// <returns></returns>
        public static StringBuilder ToCSharpCode(Translation translation)
        {
            return ToCSharpCode(translation, Namespace, ClassName);
        }

        /// <summary>
        /// Creates StringBuilder with C# code of translation.
        /// </summary>
        /// <param name="translation">The translation.</param>
        /// <param name="runtimeNamespace">The runtime namespace.</param>
        /// <param name="runtimeClassName">Name of the runtime class.</param>
        /// <returns></returns>
        public static StringBuilder ToCSharpCode(Translation translation,
            string runtimeNamespace, string runtimeClassName)
        {
            StringBuilder str = new StringBuilder();
            str.AppendLine("// NLocalizer (C) Krzysztof Arkadiusz Prusik, NLocalizer.codeplex.com");
            string lang = "";
            foreach (KeyValuePair<string, TranslationClasses> item in translation)
                lang += item.Key + ", ";
            str.AppendLine(String.Format("// Code file to languages: {0} autogenerated {1}",
                lang, DateTime.Now.ToShortDateString()));
            str.AppendLine("// $Id" + "$");
            str.AppendLine();
            foreach (string usingName in translation.CodeUsings)
                str.AppendLine(String.Format("using {0};", usingName));
            str.AppendLine();
            str.AppendLine("namespace " + runtimeNamespace);
            str.AppendLine("{");
            str.AppendLine("    public static class " + runtimeClassName);
            str.AppendLine("    {");

            if (translation.Exists("English"))
            {
                foreach (KeyValuePair<string, TranslationProperties> item in translation["English"])
                    str.Append(ToCSharpCode(item.Key, translation));

                str.AppendLine("        public static void Translate()");
                str.AppendLine("        {");
                str.AppendLine("            Translate(Translator.Translation);");
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine("        public static void Translate(Translation translation)");
                str.AppendLine("        {");
                str.AppendLine("            Translate(translation.CurrentLanguage, translation);");
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine("        public static void Translate(string language, Translation translation)");
                str.AppendLine("        {");
                foreach (string staticClassName in translation.StaticClasses)
                    str.AppendLine(String.Format("            Translate{0}(language, translation);", staticClassName));
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine("        public static void Remember()");
                str.AppendLine("        {");
                str.AppendLine("            Remember(Translator.Translation);");
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine("        public static void Remember(Translation translation)");
                str.AppendLine("        {");
                foreach (string staticClassName in translation.StaticClasses)
                {
                    str.AppendLine(String.Format("            Remember{0}(translation);", staticClassName));
                }
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine("        public static void Restore()");
                str.AppendLine("        {");
                str.AppendLine("            Restore(Translator.Translation);");
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine("        public static void Restore(Translation translation)");
                str.AppendLine("        {");
                foreach (string staticClassName in translation.StaticClasses)
                {
                    str.AppendLine(String.Format("            Restore{0}(translation);", staticClassName));
                }
                str.AppendLine("        }");
                str.AppendLine();
            }

            str.AppendLine("    }");
            str.AppendLine("}");
            return str;
        }

        /// <summary>
        /// Creates StringBuilder with C# code of translation class.
        /// </summary>
        /// <param name="className">Name of the class.</param>
        /// <param name="translation">The translation.</param>
        /// <returns></returns>
        public static StringBuilder ToCSharpCode(string className, Translation translation)
        {
            StringBuilder str = new StringBuilder();
            if (translation.StaticClasses.Contains(className))
            {
                str.AppendLine(String.Format("        public static void Remember{0}()", className));
                str.AppendLine("        {");
                str.AppendLine(String.Format("            Remember{0}(Translator.Translation);", className));
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine(String.Format("        public static void Remember{0}(Translation translation)", className));
                str.AppendLine("        {");
                
                if (translation.Exists("English"))
                    foreach (KeyValuePair<string, string> item in translation["English"][className])
                        str.AppendLine(String.Format("            translation.SetText(\"Neutral\", \"{0}\", \"{1}\", {0}.{1});", className, item.Key));
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine(String.Format("        public static void Restore{0}()", className));
                str.AppendLine("        {");
                str.AppendLine(String.Format("            Restore{0}(Translator.Translation);", className));
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine(String.Format("        public static void Restore{0}(Translation translation)", className));
                str.AppendLine("        {");
                str.AppendLine(String.Format("            if (translation.Exists(\"Neutral\", \"{0}\"))", className));
                str.AppendLine(String.Format("                Translate{0}(\"Neutral\", translation);", className));
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine(String.Format("        public static void Translate{0}(string language)", className));
                str.AppendLine("        {");
                str.AppendLine(String.Format("            Translate{0}(language, Translator.Translation);", className));
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine(String.Format("        public static void Translate{0}(string language, Translation translation)", className));
                str.AppendLine("        {");
                str.AppendLine(String.Format("            if (translation.Exists(\"Neutral\", \"{0}\") == false)", className));
                str.AppendLine(String.Format("                Remember{0}(translation);", className));

                str.AppendLine();
                if (translation.Exists("English", className))
                    foreach (KeyValuePair<string, string> item in translation["English"][className])
                        str.AppendLine(String.Format("            {0}.{1} = translation.GetText(language, \"{0}\", \"{1}\");",
                            className, item.Key));
                str.AppendLine("        }");
            }
            else
            {
                str.AppendLine(String.Format("        public static {0} Create{0}()", className));
                str.AppendLine("        {");
                str.AppendLine(String.Format("            return new {0}();", className));
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine(String.Format("        public static void Remember({0} obj)", className));
                str.AppendLine("        {");
                str.AppendLine("            Remember(obj, Translator.Translation);");
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine(String.Format("        public static void Remember({0} obj, Translation translation)", className));
                str.AppendLine("        {");
                if (translation.Exists("English"))
                {
                    foreach (KeyValuePair<string, string> item in translation["English"][className])
                        str.AppendLine(String.Format("            translation.SetText(\"Neutral\", \"{0}\", \"{1}\", obj.{1});", className, item.Key));

                    foreach (string staticClassName in translation.StaticClasses)
                    {
                        str.AppendLine(String.Format("            if (translation.Exists(\"Neutral\", \"{0}\") == false)", staticClassName));
                        str.AppendLine(String.Format("                Remember{0}(translation);", staticClassName));
                    }
                }
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine(String.Format("        public static void Restore({0} obj)", className));
                str.AppendLine("        {");
                str.AppendLine("            Restore(obj, Translator.Translation);");
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine(String.Format("        public static void Restore({0} obj, Translation translation)", className));
                str.AppendLine("        {");
                str.AppendLine(String.Format("            if (translation.Exists(\"Neutral\", \"{0}\"))", className));
                str.AppendLine("                Translate(\"Neutral\", obj, translation);");
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine(String.Format("        public static void Translate(string language, {0} obj)", className));
                str.AppendLine("        {");
                str.AppendLine("            Translate(language, obj, Translator.Translation);");
                str.AppendLine("        }");
                str.AppendLine();

                str.AppendLine(String.Format("        public static void Translate(string language, {0} obj, Translation translation)", className));
                str.AppendLine("        {");
                str.AppendLine(String.Format("            if (translation.Exists(\"Neutral\", \"{0}\") == false)", className));
                str.AppendLine("                Remember(obj, translation);");
                str.AppendLine();
                if (translation.Exists("English", className))
                    foreach (KeyValuePair<string, string> item in translation["English"][className])
                        str.AppendLine(String.Format("            obj.{1} = translation.GetText(language, \"{0}\", \"{1}\");",
                            className, item.Key));
                str.AppendLine("        }");
            }
            return str;
        }

        /// <summary>
        /// Gets the default compile directory (current assembly directory).
        /// </summary>
        /// <returns></returns>
        public static string GetDefaultCompileDirectory()
        {
            return Path.GetDirectoryName(Assembly.GetExecutingAssembly().CodeBase.Replace("file:///", ""));
        }

        /// <summary>
        /// Compiles the specified translation in directory.
        /// </summary>
        /// <param name="translation">The translation.</param>
        /// <param name="directoryName">Name of the directory.</param>
        /// <returns></returns>
        public static CompilerResults Compile(Translation translation, string directoryName)
        {
            return Compile(translation, directoryName, Namespace, ClassName);
        }

        /// <summary>
        /// Compiles the specified translation.
        /// </summary>
        /// <param name="translation">The translation.</param>
        /// <returns></returns>
        public static CompilerResults Compile(Translation translation)
        {
            return Compile(translation, Namespace, ClassName);
        }

        /// <summary>
        /// Compiles the specified translation.
        /// </summary>
        /// <param name="translation">The translation.</param>
        /// <param name="runtimeNamespace">The runtime namespace.</param>
        /// <param name="runtimeClassName">Name of the runtime class.</param>
        /// <returns></returns>
        public static CompilerResults Compile(Translation translation, 
            string runtimeNamespace, string runtimeClassName)
        {
            return Compile(translation, GetDefaultCompileDirectory(), runtimeNamespace, runtimeClassName);
        }

        /// <summary>
        /// Compiles the specified translation.
        /// </summary>
        /// <param name="translation">The translation.</param>
        /// <param name="directoryName">Name of the directory.</param>
        /// <param name="runtimeNamespace">The runtime namespace.</param>
        /// <param name="runtimeClassName">Name of the runtime class.</param>
        /// <returns></returns>
        public static CompilerResults Compile(Translation translation, string directoryName, 
            string runtimeNamespace, string runtimeClassName)
        {
            CompilerParameters parameters = new CompilerParameters();
            parameters.GenerateInMemory = true;
            parameters.TreatWarningsAsErrors = false;
            parameters.GenerateExecutable = false;
            parameters.CompilerOptions = "/optimize";
            parameters.ReferencedAssemblies.AddRange(translation.CodeModules.ToArray());
            CSharpCodeProvider provider = new CSharpCodeProvider();
            string lastDirectory = Directory.GetCurrentDirectory();
            CompilerResults compiler = null;
            try
            {
                Directory.SetCurrentDirectory(directoryName);
                compiler = provider.CompileAssemblyFromSource(parameters,
                    new string[] { RuntimeCompiler.ToCSharpCode(translation).ToString() });
                if (compiler.Errors.HasErrors)
                {
                    StringBuilder str = new StringBuilder();
                    foreach (CompilerError ce in compiler.Errors)
                        str.AppendLine(ce.ToString());
                    throw new Exception("Compile error\r\n" + str.ToString());
                }
            }
            finally
            {
                Directory.SetCurrentDirectory(lastDirectory);
            }
            return compiler;
        }

        /// <summary>
        /// Gets the compiled class from compiler.
        /// </summary>
        /// <param name="compiler">The compiler.</param>
        /// <returns></returns>
        public static Type GetCompiledClass(CompilerResults compiler)
        {
            return GetCompiledClass(compiler, Namespace, ClassName);
        }

        /// <summary>
        /// Gets the compiled class from compiler.
        /// </summary>
        /// <param name="compiler">The compiler.</param>
        /// <param name="runtimeNamespace">The runtime namespace.</param>
        /// <param name="runtimeClassName">Name of the runtime class.</param>
        /// <returns></returns>
        public static Type GetCompiledClass(CompilerResults compiler, string runtimeNamespace, string runtimeClassName)
        {
            if (compiler == null || compiler.CompiledAssembly == null)
                throw new Exception("Runtime translator not compiled");

            if (compiler.CompiledAssembly.GetModules().Length < 1)
                throw new Exception("No modules in runtime translator");

            Module module = compiler.CompiledAssembly.GetModules()[0];
            if (module == null)
                throw new Exception("No modules in runtime translator");

            Type type = module.GetType(runtimeNamespace + "." + runtimeClassName);
            if (type == null)
                throw new Exception(String.Format(
                    "Type {0}.{1} is not found in runtime translator", runtimeNamespace, runtimeClassName));

            return type;
        }

        /// <summary>
        /// Invokes the specified method in type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="methodName">Name of the method.</param>
        /// <param name="types">The types of parameters.</param>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public static object Invoke(Type type, string methodName, Type[] types, object[] parameters)
        {
            MethodInfo method;
            if (types != null)
                method = type.GetMethod(methodName, types);
            else
                method = type.GetMethod(methodName);
            
            if (method == null)
            {
                string typeParams = "";
                foreach (Type t in types)
                    typeParams += t.Name + ", ";
                if (typeParams != "")
                    typeParams = typeParams.Substring(0, typeParams.Length - ", ".Length);
                throw new Exception(String.Format(
                    "Method {0}({1}) is not found in runtime translator class {2}",
                    methodName, typeParams, type.FullName));
            }
            return method.Invoke(null, parameters);
        }

        /// <summary>
        /// Translates the specified type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="translation">The translation.</param>
        public static void Translate(Type type, Translation translation)
        {
            Invoke(type, MethodTranslate,
                new Type[] { translation.GetType() },
                new object[] { translation });
        }

        /// <summary>
        /// Translates all static classes into language.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="language">The language.</param>
        /// <param name="translation">The translation.</param>
        public static void Translate(Type type, string language, Translation translation)
        {
            Invoke(type, MethodTranslate,
                new Type[] { language.GetType(), translation.GetType() },
                new object[] { language, translation });
        }

        /// <summary>
        /// Translates the specified obj into language.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="language">The language.</param>
        /// <param name="obj">The obj.</param>
        /// <param name="translation">The translation.</param>
        public static void Translate(Type type, string language, object obj, Translation translation)
        {
            Invoke(type, MethodTranslate,
                new Type[] { language.GetType(), obj.GetType(), translation.GetType() },
                new object[] { language, obj, translation });
        }

        /// <summary>
        /// Translates the specified obj into current language.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="obj">The obj.</param>
        /// <param name="translation">The translation.</param>
        public static void Translate(Type type, object obj, Translation translation)
        {
            Translate(type, translation.CurrentLanguage, obj, translation);
        }

        /// <summary>
        /// Restores all static classes into neutral language.
        /// </summary>
        /// <param name="type">The type.</param>
        public static void Restore(Type type)
        {
            Invoke(type, MethodRestore, null, null);
        }

        /// <summary>
        /// Restores all static classes into neutral language.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="translation">The translation.</param>
        public static void Restore(Type type, Translation translation)
        {
            Invoke(type, MethodRestore,
                new Type[] { translation.GetType() },
                new object[] { translation });
        }

        /// <summary>
        /// Restores the specified obj into neutral language.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="obj">The obj.</param>
        /// <param name="translation">The translation.</param>
        public static void Restore(Type type, object obj, Translation translation)
        {
            Invoke(type, MethodRestore,
                new Type[] { obj.GetType(), translation.GetType() },
                new object[] { obj, translation });
        }

        /// <summary>
        /// Creates the specified className.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="className">Name of the class.</param>
        /// <returns></returns>
        public static object Create(Type type, string className)
        {
            return Invoke(type, MethodCreate + className, null, null);
        }

        /// <summary>
        /// Shows the dialog of specified className.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="className">Name of the class.</param>
        public static void ShowDialog(Type type, string className)
        {
            object obj = Create(type, className);
            if (obj != null && obj is Form)
                Invoke(type, MethodShowDialog, null, null);
        }
    }
}